The following section covers different aspects of TinySpline's API. For the
sake of convenience, the listed snippets use the Python interface. Yet, you
should be able to port the code to your preferred language. You may also have a
look at the examples hosted at [Github](@TINYSPLINE_URL@/tree/master/examples).

## Creating Splines

__B-Splines:__ Creating a B-Spline is straightforward. Pass the number of
required control points to the constructor of the `BSpline` class:

```python
spline = BSpline(7)
```

This creates a two-dimensional, cubic (degree = 3) B-Spline with 7 control
points and a clamped knot vector. Instead of using the default values, the
dimension of the control points, the degree of the B-Spline, and the generator
that is used to setup the knot vector can be specified explicitly:

```python
spline = BSpline(7, 3, 4, OPENED)
```

The second example creates a three-dimensional, quartic (degree = 4) B-Spline
with 7 control points and an opened knot vector.

__Bézier Curves:__ Bézier curves are a special case of general B-Splines: The
number of control points of a Bézier _c_ is equal to the order (degree + 1) of
_c_. The following example creates a cubic Bézier curve (_dim_ is the desired
dimension of _bezier_) and stores it as BSpline object:

```python
bezier = BSpline(4, dim, 3)
```

__Lines and Points:__ Lines and points are represented as BSpline objects as
well. A line is a Bézier curve of degree one consisting of two control points
(if the number of control points is greater than two, the resultant spline is a
sequence of connected lines):

```python
line = BSpline(2, dim, 1)
```

Similarly, a point is a Bézier curve of degree zero consisting of a single
control point (if the number of control points is greater than one, the
resultant spline is a sequence of points):

```python
point = BSpline(1, dim, 0)
```

__NURBS__: As for Bézier curves, lines, and points, there is no discrete class
for NURBS because NURBS are B-Splines whose control points are stored in
[homogeneous coordinates](https://en.wikipedia.org/wiki/Homogeneous_coordinates)
(also referred to as projective coordinates). To obtain a _n_-dimensional
NURBS, create a B-Spline with dimension _n+1_.

!!! note
    There is also a default constructor which creates a three-dimensional point
    located at (0, 0, 0). This constructor is primarily used by the C++
    interface and allows to store instances of the BSpline class in arrays
    and other data structures that require a default constructor. However, it
    may also be useful in cases where some sort of a _default_ value is
    necessary.

## Accessing the Control Points

The property `control_points` allows to read and write the control points of
a spline (other languages may use language-specific accessor methods):

```python
spline = BSpline(7)
ctrlp  = spline.control_points
```

Control points (as for all types of points in TinySpline) are stored as
one-dimensional list. To decompose a list of control points into individual
point elements, use the following pattern:

```python
spline = BSpline(7, 2)
ctrlp  = spline.control_points
for i in range(len(ctrlp) / spline.dimension):
        px = ctrlp[i * spline.dimension]
        py = ctrlp[i * spline.dimension + 1]
        ...
```
!!! note
    Properties (accessor methods) return deep copies of their fields so
    that modifying the returned data doesn't affect the internal state of
    the corresponding object. To apply changes, the modified data has to
    assigned to the property explicitly (which in turn creates a deep copy
    of the given input values to encapsulate the internal state).


## Drawing Splines

TinySpline has no built-in support for drawing splines. However, you can use
any GUI toolkit (Qt, GTK, TkInter, JavaFX, you name it) to display BSpline
objects. In principle, there are different ways to render a spline:

- If the GUI toolkit supports B-Splines/NURBS out-of-the-box (e.g.
  [GLUT](https://www.glprogramming.com/red/chapter12.html)), simply pass the
  required values (most probably control points, knots, degree, and dimension)
  to the corresponding function.

- If the GUI toolkit supports Bézier curves, decompose the spline into a
  sequence of connected Bézier curves by using the `to_beziers()` method.
  Then, draw the Bézier curves one after another. The following example gives a
  pattern:

```python
spline = BSpline(7, 2)
beziers = spline.to_beziers().control_points
for c in range(int(len(beziers)) / spline.dimension / spline.order):
        p0x = beziers[c * spline.order * spline.dimension]
        p0y = beziers[c * spline.order * spline.dimension + 1]
        p1x = beziers[c * spline.order * spline.dimension + 2]
        p1y = beziers[c * spline.order * spline.dimension + 3]
        p2x = beziers[c * spline.order * spline.dimension + 4]
        p2y = beziers[c * spline.order * spline.dimension + 5]
        p3x = beziers[c * spline.order * spline.dimension + 6]
        p3y = beziers[c * spline.order * spline.dimension + 7]
        ...
```

- Some frameworks allow to render Catmull-Rom splines (e.g. Unreal Engine 4).
  Although Catmull-Rom splines are not supported explicitly by TinySpline,
  converting a B-Spline into a sequence of Catmull-Rom splines is not too
  difficult. First, decompose the B-Spline into a sequence of Bézier curves (see
  above). Then, convert each Bézier curve into a Catmull-Rom spline using the
  formulas described at
  [A Primer on Bézier Curves](https://pomax.github.io/bezierinfo/#catmullconv).
  Finally, draw the Catmull-Rom splines one after another.

- If the GUI toolkit has no built-in support for any kind of spline, decompose
  the spline into a sequence of points (by using the `sample()` method) and
  draw the points as connected lines:

```python
spline = BSpline(7, 2)
points = spline.sample()
for p in range(int(len(points)) / spline.dimension - 1):
        p0x = points[p * spline.dimension]
        p0y = points[p * spline.dimension + 1]
        p1x = points[(p+1) * spline.dimension]
        p1y = points[(p+1) * spline.dimension + 1]
        ...
```

!!! note
    The `sample()` method allows to specify the number of sampled points. The
    default value (0), for the sake of convenience, tries to estimate a decent
    number of points so that the corresponding spline doesn't look too edgy.
    However, you may want to adjust the number of sampled points for your use
    case in order to optimize performance. That being said, TinySpline can
    easily sample thousands of points in less than a millisecond.

## Evaluating Splines

Evaluation is the process of extracting points (laying on a spline) based on a
certain type of parameter. Two different types of evaluation are supported:
_knot-based evaluation_ and _bisection-based evaluation_. The former is
probably the best known form of evaluation while the latter is useful when
interpolating functions.

__Knot-based Evaluation:__ B-Splines, as well as NURBS, lines, and points (due
to being represented as B-Spline objects), are defined over a closed interval
(also referred to as _domain_). A spline's domain is specified by a so-called
_knot vector_ (or simply _knots_), which is a monotonically increasing sequence
of numbers. The sequence is not strictly monotone so that a knot vector may
contain the same knot multiple times. Yet, a knot's multiplicity must be less
than or equal to the order (degree + 1) of the spline it belongs to:
_multiplicity(knot) <= spline.order_. In addition, the knot vector of a spline
contains exactly _ncp(spline) + spline.order_ knots (with _ncp_ being the
number of control points). The most common domain is [0, 1] and could be
structured as follows (for a cubic spline with seven control points):

    knots = [0, 0, 0, 0, 0.25, 0.5, 0.75, 1, 1, 1, 1]

Using knot vectors where the multiplicity of the first and last knot is equal
to the order (four in this example) of a spline is common practice to let the
spline pass through its first and last control point respectively. These kinds
of knot vectors are called _clamped_ knot vectors because the corresponding
spline is clamped at its outer control points. If the first and last knot do
not have multiplicity _order_, the corresponding knot vector is _open_. An
opened knot vector could be structured as follows (for a cubic spline with
seven control points):

    [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]

!!! note
    The minimum of the domain of a spline _s_ is _knots[s.order]_.  Likewise,
    the maximum of the domain of  _s_ is _knots[-s.order]_. Thus, the first and
    last _s.degree_ knots of the knot vector of _s_ do not specify the domain
    of _s_.

Knot-based evaluation means that (as the name suggests) points are extracted
from splines by means of certain knots. For example, let _s_ be a spline with
domain [u0, u1]. Evaluating _s_ at knot _u_ (with _u0 <= u <= u1)_ returns a
point laying on _s_. By iteratively evaluating _s_ from _u0_ to _u1_ (i.e.,
iterating from _u0_ to _u1_ in small steps), one can extract a sequence of
consecutive points which approximate _s_ (this is how the _sample()_ method
works). To evaluate a spline at a certain knot, use the `eval()` method or, if
the programming language of the binding supports operator overloading, the `()`
operator:

```python
spline = BSpline(7)
spline.eval(0.3)
spline(0.26)
```

!!! note
    Within the domain of a spline, the knot to evaluate may have any value.
    That is, it doesn't necessarily have to be a knot of the knot vector.

!!! note
    In PHP the method is named `c_eval()`.

The result of _eval()_  isn't a sole point, but an instance of the `DeBoorNet`
class. Knots are evaluated by iteratively computing a net of intermediate
values until the resultant point is available (De Boor's algorithm). The
DeBoorNet class not only stores the resultant point, but also the entire net
that was necessary to obtain it (as well as additional properties, such as the
multiplicity of the evaluated knot). The net of intermediate values (including
the resultant point) can be read from the `points` property. The property
`result` allows to access the sole point:

```python
spline = BSpline(7)
spline(0.95).result
```

__Bisection-based Evaluation:__ This type of evaluation is useful in cases
where a spline represents a function, i.e. its control points are strictly
monotone (increasing or decreasing) at one of the components (e.g. the
x-coordinate). In such cases, it might be of interest, for example, to query
the y-coordinate of a given x-coordinate. Another example are time series: The
first component of the control points store a point in time (e.g. seconds) and
the remaining components store a location (e.g. x-, y- and z-coordinates). Now
one can query a location at a certain point in time. This type of evaluation
(where a specific component is the input parameter) is provded by the
`bisect()` method:

```python
spline = BSpline(2, 2, 1)
ctrlp = spline.control_points
ctrlp[0] = 0
ctrlp[1] = 1
ctrlp[2] = 1
ctrlp[3] = 0
spline.control_points = ctrlp
spline.bisect(0.3)
```

As for the _eval()_ method, the result of _bisect()_ isn't a sole point, but
an instance of the `DeBoorNet` class, which, for a given input _i_, contains
an approximated knot value _u_ such that _eval(u)_ evaluates to a point _p_
whose distance between the desired component (_c_) of _p_ and _i_ is less than
or  equal to a threshold (_epsilon_): _distance(i, eval(u).result[c]) <=
epsilon_. The approximated knot is determined by combining knot-based
evaluation with bisection (which is binary search in continous space). The
default value of _epsilon_ is _0.01_ but can be changed with the second
parameter of the _bisect()_ method.

It is also possible to pass a value which exceed the limits of the outer
control points. That is, for instance, in the example listed above one can
also pass _-1_ (which falls below the first component of the first control
point) and _2_ (which exceeds the first component of the last control point).
In such case, the best matching point (the point with the minimum distance) is
returned. However, this behaviour can be changed by setting the third
parameter of the _bisect()_ method (with the very speaking name _persnickety_)
to _True_. If _persnickety_ is _True_, an exception rather than the best
matching point is thrown.

By default, it is expected that the first component (index 0) of the control
points is strictly increasing. This is a sane default because in most cases
the first component encodes some sort of serial value (e.g. time). Yet, one
may want to specify another component to be evaluated or the relevant values
of the control points are strictly decreasing. The default values can be
overwritten with the forth (named _index_) and fifth (named _ascending_)
parameter of the _bisect()_ method respectively.

Finally, the sixth parameter of the _bisect()_ method (_maxIter_) allows to
set the maximum number of knot-based evaluations before (depending on
parameter _persnickety_) returning the best matching point or throwing an
exception. The default value is _30_. The following listing reuses the
previous example and makes use of all six parameters:

```python
spline = BSpline(2, 2, 1)
ctrlp = spline.control_points
ctrlp[0] = 0
ctrlp[1] = 1
ctrlp[2] = 1
ctrlp[3] = 0
spline.control_points = ctrlp
spline.bisect(0.3, 0.1, True, 1, False, 10)
```


## Accessing the Knot Vector

## Inserting Knots and Knot Refinement

## Derive Splines

## Spline Interpolation

## Error Handling
